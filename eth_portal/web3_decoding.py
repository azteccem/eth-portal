from eth.rlp.headers import (
    BlockHeader,
)
from eth.vm.forks.london.blocks import (
    LondonBlockHeader,
)
from eth_hash.auto import (
    keccak,
)
from eth_utils import (
    ValidationError,
    to_bytes,
    to_int,
)
from eth_utils.toolz import (
    assoc,
)
import rlp


def block_fields_to_header(web3_block_fields):
    """
    Convert a web3 block into an rlp-serializable object.

    A web3 block is the result of a w3.eth.getBlock() request. An
    rlp-serializable object is one that can be passed in as an argument to
    rlp.encode(). Hashing that result must always return the hash of the block.

    If uncles are not empty, then `web3_block_fields` must be explicitly augmented
    with an 'uncleHeaders' field, which is a list of web3 header objects, one
    for each header. (order matters)
    """
    header_fields = _select_header_fields(web3_block_fields)
    if 'base_fee_per_gas' in header_fields:
        return LondonBlockHeader(**header_fields)
    else:
        return BlockHeader(**header_fields)


def _select_header_fields(block_fields):
    """
    Select and format the fields needed to create an RLP Serializable object.

    Inspired by py-evm's eth/tools/fixtures/helpers.py
    """
    base_fields = {
        'parent_hash': block_fields['parentHash'],
        'coinbase': to_bytes(hexstr=block_fields['miner']),
        'state_root': block_fields['stateRoot'],
        'transaction_root': block_fields['transactionsRoot'],
        'receipt_root': block_fields['receiptsRoot'],
        'bloom': to_int(block_fields['logsBloom']),
        'difficulty': block_fields['difficulty'],
        'block_number': block_fields['number'],
        'gas_limit': block_fields['gasLimit'],
        'gas_used': block_fields['gasUsed'],
        'timestamp': block_fields['timestamp'],
        'extra_data': block_fields['extraData'],
        'mix_hash': block_fields['mixHash'],
        'nonce': block_fields['nonce'],
    }

    # uncleHeaders is a custom field not normally provided by web3. It is
    # generated by calling w3.eth.getBlock() on each uncle header hash, and
    # combining that into a list of headers
    if 'uncleHeaders' in block_fields:
        uncles = [block_fields_to_header(uncle) for uncle in block_fields['uncleHeaders']]
        encoded_uncle_list = rlp.encode(uncles)
        base_fields['uncles_hash'] = keccak(encoded_uncle_list)
    elif block_fields['uncles']:
        # Without this information, we cannot calculate the uncles_hash, which
        # means we cannot generate the full RLP object.
        raise ValidationError("Header dict with uncles must add uncleHeaders list")

    if 'baseFeePerGas' in block_fields:
        return assoc(base_fields, 'base_fee_per_gas', block_fields['baseFeePerGas'])
    else:
        return base_fields
